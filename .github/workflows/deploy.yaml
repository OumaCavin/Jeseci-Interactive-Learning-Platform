name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      debug_enabled:
        description: 'Enable debug mode'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Deployment Decision
  deploy-decision:
    name: Deployment Decision
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.decision.outputs.environment }}
      should-deploy: ${{ steps.decision.outputs.should-deploy }}
    
    steps:
      - name: Determine deployment environment
        id: decision
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  # Build and Push Images
  build-images:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: deploy-decision
    if: needs.deploy-decision.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for backend
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ needs.deploy-decision.outputs.environment }}-latest
            type=raw,value=latest

      - name: Extract metadata for frontend
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ needs.deploy-decision.outputs.environment }}-latest
            type=raw,value=latest

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.deploy-decision.outputs.environment }}-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.deploy-decision.outputs.environment }}-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to Staging (Docker Compose)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [deploy-decision, build-images]
    if: needs.deploy-decision.outputs.environment == 'staging'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/jeseci-staging
            git pull origin main
            
            # Create docker-compose override for staging
            cat > docker-compose.override.yml << EOF
            version: '3.8'
            services:
              backend:
                environment:
                  - DEBUG=False
                  - SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
                  - DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }}
                  - REDIS_URL=${{ secrets.STAGING_REDIS_URL }}
                  - OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
              frontend:
                environment:
                  - REACT_APP_API_URL=https://staging.jeseci.com/api
            EOF
            
            # Pull latest images
            docker-compose pull
            
            # Deploy with zero downtime
            docker-compose up -d --remove-orphans
            
            # Wait for services to be healthy
            timeout 300 bash -c 'until curl -f https://staging.jeseci.com/api/health/; do echo "Waiting for deployment..."; sleep 10; done'
            
            # Run database migrations
            docker-compose exec -T backend python manage.py migrate
            
            echo "Staging deployment completed successfully"

  # Deploy to Production (Kubernetes)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-decision, build-images]
    if: needs.deploy-decision.outputs.environment == 'production'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Deploy to Kubernetes
        run: |
          # Set kubeconfig
          export KUBECONFIG="${{ secrets.KUBE_CONFIG }}"
          
          # Add Helm repositories
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          
          # Install/Update ingress-nginx if not exists
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.replicaCount=2 \
            --set controller.nodeSelector."beta\.kubernetes\.io/os"=linux \
            --set defaultBackend.nodeSelector."beta\.kubernetes\.io/os"=linux
            
          # Update Helm values for production
          helm upgrade --install jeseci-platform ./infra/helm/jeseci-platform \
            --namespace jeseci-production \
            --create-namespace \
            --values ./infra/helm/values-production.yaml \
            --set image.tag=${{ github.sha }} \
            --set environment=production \
            --wait \
            --timeout=600s

      - name: Verify deployment
        run: |
          export KUBECONFIG="${{ secrets.KUBE_CONFIG }}"
          
          # Wait for rollout to complete
          kubectl rollout status deployment/jeseci-backend -n jeseci-production --timeout=600s
          kubectl rollout status deployment/jeseci-frontend -n jeseci-production --timeout=600s
          
          # Get service endpoints
          kubectl get services -n jeseci-production

  # Post-deployment Testing
  post-deployment-test:
    name: Post-deployment Testing
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run smoke tests
        run: |
          # Determine environment URL
          if [ "${{ needs.deploy-staging.result }}" == "success" ]; then
            BASE_URL="https://staging.jeseci.com"
          else
            BASE_URL="https://jeseci.com"
          fi
          
          # Run smoke tests
          curl -f "$BASE_URL/api/health/" || exit 1
          curl -f "$BASE_URL/" || exit 1
          
          # Test key endpoints
          curl -f "$BASE_URL/api/skill_map/" || exit 1
          
          echo "Smoke tests passed"

  # Notify deployment status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-decision, deploy-staging, deploy-production, post-deployment-test]
    if: always()
    
    steps:
      - name: Notify Slack on success
        if: ${{ needs.post-deployment-test.result == 'success' }}
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: 'üöÄ Jeseci Platform deployment to ${{ needs.deploy-decision.outputs.environment }} completed successfully!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: Notify Slack on failure
        if: ${{ needs.post-deployment-test.result == 'failure' }}
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: '‚ùå Jeseci Platform deployment to ${{ needs.deploy-decision.outputs.environment }} failed!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}